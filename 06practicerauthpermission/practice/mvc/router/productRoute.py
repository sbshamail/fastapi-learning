from fastapi import APIRouter, Depends
from sqlalchemy.orm import selectinload
from sqlmodel import Session, select

from practice.lib.db import get_session
from practice.lib.response import (
    api_response,
)
from practice.mvc.core.security import (
    require_signin,
)
from practice.mvc.models.productModel import (
    Product,
    ProductCreate,
    ProductRead,
)

router = APIRouter(prefix="/product", tags=["product"])
require_signin = Depends(require_signin)


@router.post("/create", response_model=Product)
def create(
    request: ProductCreate,
    session: Session = Depends(get_session),
    auth=require_signin,
):
    # Create Product from incoming request data
    product = Product(**request.model_dump())  # like new Product(req.body)

    # Save to DB
    session.add(product)
    session.commit()

    # Refresh to load autogenerated fields (e.g., id)
    session.refresh(product)

    # Return structured response
    return api_response(200, "Product created", product)


@router.get(
    "/all",
    response_model=list[ProductRead],
)
def list(
    session: Session = Depends(get_session),
):
    # selectinload like populate in mongoose
    statement = select(Product).options(selectinload(Product.owner))  # JOIN user
    data = session.exec(statement).all()

    if not data:
        return api_response(404, "Product not found")
    # Convert each SQLModel Product instance into a ProductRead Pydantic model
    # This ensures relationships like `owner` are included in the serialized output
    product_list = [ProductRead.model_validate(prod) for prod in data]

    return api_response(
        200,
        "Products fetched",
        product_list,
        len(product_list),
    )


@router.get("/{id}", response_model=ProductRead)
def read(
    id: int,
    session: Session = Depends(get_session),
):
    statement = (
        select(Product).where(Product.id == id).options(selectinload(Product.owner))
    )
    result = session.exec(statement).first()
    if not result:
        return api_response(404, "Product not found")
    product = ProductRead.model_validate(result)
    return api_response(200, "Product Found", product)


@router.delete("/{id}", response_model=dict)
def delete(
    id: int,
    session: Session = Depends(get_session),
):
    user = session.get(Product, id)
    if not user:
        return api_response(404, "User not found")

    session.delete(user)
    session.commit()
    return api_response(200, f"Product {id} deleted")
